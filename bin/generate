#!/usr/bin/env python3

"""create a simple blog from markdown files

From within this kind of directory structure:

    ./content/
              grinds-my-gears.md
              gear.png
              happy_new_year.md
              not_a_post.md
   
    ./config/
             navigate.html
             style.css

    ./posts/
            2018-01-01  -> ../content/happy_new_year.md
            2018-01-05  -> ../content/grinds-my-gears.md

    ./site/

Run this script in `./` to generate HTML files and symlinks in the `./site/`
directory derived from or pointing to files in `./content`.

The result will be

    ./content/
              grinds-my-gears.md
              gear.png
              happy_new_year.md
              not_a_post.md
   
    ./config/
             navigate.html
             style.css

    ./posts/
            2018-01-01  ->  ../content/happy_new_year.md
            2018-01-05  ->  ../content/grinds-my-gears.md

    ./site/
           grinds-my-gears.html
           gear.png  ->  ../content/gear.png
           happy_new_year.html
           not_a_post.html
           posts.html
           index.html  ->  ./grinds-my-gears.html
"""

import mistune
import linkify
import tableofcontents

from datetime import datetime
from pathlib import Path
from xml.etree import ElementTree as ET

# Note that this is actually XML.  I omit the XHTML-required "!DOC" stuff,
# though, because I found that it caused browsers to ignore CSS's max-width
# style.
html_template = '''
<html>
<!-- Note that this is actually XML. I omit the XHTML-required "!DOC" stuff,
     though, because I found that it caused browsers to ignore CSS's max-width
     style. -->
<head>
  <meta charset="UTF-8" />

  <link rel="shortcut icon" type="image/x-icon" href="/site/favicon.ico" />

  <!-- style for landscape orientation, e.g. desktop browser -->
  <link rel="stylesheet" type="text/css"
      media="(orientation: landscape)"
      href="/site/landscape.css" />

  <!-- style for portrait orientation, e.g. mobile browser -->
  <link rel="stylesheet" type="text/css"
      media="(orientation: portrait)"
      href="/site/portrait.css" />

  <link rel="stylesheet" href="/highlightjs/styles/default.css" />

  <!-- The space character prevents etree from omitting the closing tag. -->
  <script src="/highlightjs/highlight.pack.js"> </script>

  <script>hljs.initHighlightingOnLoad();</script>

  <title>{title}</title>
</head>

<body>

{navigate}

{date}

{table_of_contents}

{content}

{navigate}

</body>
</html>
'''

def get_first_h1(html_markup):
    begin = html_markup.find('<h1>') + len('<h1>')
    if begin == -1:
        return None
    end = html_markup.find('</h1>', begin)
    if end == -1:
        return None

    return html_markup[begin:end]

_markdown_converter = mistune.Markdown(use_xhtml=True)

def markdown2html(markdown_path):
    "Return a string containing the HTML output of compiling markdown."
    
    return _markdown_converter(markdown_path.read_text())
      
def pretty_date(date):
    day_of_week_and_month_name = date.strftime('%A, %B ')
    return f'{day_of_week_and_month_name} {date.day}, {date.year}'

def create_page(from_path, to_path, navigate, date=None):
    """Write HTML to the specified `to_path` from the markdown at the specified
    `from_path`, the specified `navigate` HTML, and the optionally specified
    `date` object.  Return the title of the generated HTML document."""

    with to_path.open('w', encoding='utf8') as destination:
        content = markdown2html(from_path)
        title = get_first_h1(content)
        date = '<p>' + pretty_date(date) + '</p>' if date is not None else ''
        title = title if title is not None else ''
        toc = '<div class="table-of-contents"></div>'
        html = html_template.format(title=title,
                                    navigate=navigate,
                                    date=date,
                                    table_of_contents=toc,
                                    content=content)
        html = ET.fromstring(html)

        if date:
            # This is a post, so expand the table of contents.
            tableofcontents.insert_table_of_contents(html, max_depth=2)
            
        # Wrap <img ...> tags in links of the img src is a *_small.jpg
        linkify.wrap_images(html, r'^(.*)_small\.jpg$', r'\1.jpg')

        ET.ElementTree(html).write(destination, encoding='unicode')

    return title

def create_posts(posts_list, page_titles, site, navigate):
    "Create site/posts.html using the specified arguments. `site` is a `Path`."
    
    content_template = '''
    <table class="posts">
      <tr><th align="left">Date</th><th align="right">Post</th></tr>
      {rows}
    </table>
    '''

    row_template = '''
      <tr><td align="left">{date}</td>
          <td align="right"><a href="{href}">{title}</a></td></tr>
    '''

    content_dir = Path('content').resolve()
    rows = [row_template.format(date=date,
                                href=str(path.relative_to(content_dir).with_suffix('.html')),
                                title=page_titles[path]) \
            for path, date in posts_list]

    content = content_template.format(rows='\n'.join(rows))

    with (site/'posts.html').open('w') as f:
        f.write(html_template.format(title='Posts',
                                     navigate=navigate,
                                     date='',
                                     table_of_contents='',
                                     content=content))

def up_to(descendant, ancestor):
    """Return a relative path of multiple ".." that describes the specified
    `descendent` file in terms of its specified `ancestor` directory, e.g.
    `up_to(Path('foo/bar/baz/thing.txt', 'foo'))` is `Path('../..')`.
    """
    assert not descendant.is_dir()
    assert descendant.parts[:len(ancestor.parts)] == ancestor.parts

    result = Path('.')
    for _ in range(len(descendant.parent.parts) - len(ancestor.parts)):
        result = result/Path('..')

    return result

def generate(root):
    # `posts` is a directory of symbolic links to markdown files.
    # The name of each symbolic link is an ISO-8601 date.
    # `post_dates` maps the resolved paths of the markdown files
    # to the `datetime.Date` parsed from the name of the symbolic link.
    posts = root/'posts'
    post_dates = { 
        p.resolve(): datetime.strptime(p.name, "%Y-%m-%d").date() \
        for p in posts.iterdir() if p.is_symlink()
    }

    config = root/'config'
    content = root/'content'
    navigate = (config/'navigate.html').read_text()
    site = root/'site'
    (site/'landscape.css').symlink_to('../config/landscape.css')
    (site/'portrait.css').symlink_to('../config/portrait.css')

    page_titles = {}
 
    for file_path in content.rglob('*'):
        file_path = file_path.resolve()
        name      = file_path.name
        if name.startswith('.') or name.startswith('README'):
            # ignore "hidden" files (e.g. vim swap files) and README files.
            continue
        
        relative_path = file_path.relative_to(content)
        in_site = site/relative_path
        
        # Directories get a corresponding directory under site/
        if file_path.is_dir():
            if not in_site.exists():
                in_site.mkdir()
            continue

        extension = file_path.suffix.lower()
        # If it's not a markdown file, then just create a link to it in ./site
        if extension not in ('.md', '.markdown'):
            in_site.symlink_to(up_to(in_site, root)/'content'/relative_path)
            continue

        # It's a markdown file, so generate HTML (with a date, if applicable).
        date = post_dates.get(file_path.resolve())
        html_path = in_site.with_suffix('.html')
        title = create_page(file_path,
                            html_path,
                            navigate, 
                            date)

        page_titles[file_path] = title

    # Most recent first [(full path, date) ...]
    posts_list = list(sorted(post_dates.items(),
                             key=lambda item: item[1],
                             reverse=True))

    recent_post_html_path = posts_list[0][0].relative_to(content).with_suffix('.html')
    (site/'index.html').symlink_to(recent_post_html_path)

    create_posts(posts_list, page_titles, site, navigate)

if __name__ == '__main__':
    generate(Path.cwd())
