<html>
<head>
  <meta charset="UTF-8"></meta>

  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"></link>

  
  <style>body {
    /* Limiting the width (see p below), the chosen font, the line height, and
       the color, are all based off of what github.com does when displaying
       markdown. */
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
                 Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
                 "Segoe UI Symbol";
    font-size: 16pt;
    line-height: 1.5;
    color: #24292e;
}

/* Code snippets are only as wide as their content. */
pre {
    display: table;
    min-width: 700;
}

/* Make the background of code look different from surrounding text. */
code {
    background: #F0F0F0
}

p, .navigation-bar, table.posts, ul, ol {
    max-width: 700;
}

table.posts {
    width: 100%;
	font-size: 16pt;
    line-height: 2;
}

table.posts &gt; tbody &gt; tr:nth-child(even) {
  background-color: #eee6ff
}

div.table-of-contents {
    font-size: 14pt;
}

img.thumbnail {
    width: 700px;
}

.series-navigation {
    width: 100%;
    font-size: 12pt;
    max-width: 700px;
    text-align: center;
    margin-bottom: 20px;
}

.series-navigation-header {
    font-weight: bold;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
}

.series-navigation-links {
    width: 100%;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
    flex-wrap: wrap;
}

.series-page-item .series-navigation-header {
  background-color: #eee6ff
}

.navigation-bar {
    width: 100%;
    font-size: 14pt;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
  }
</style><style>body {
    /* The chosen font, the line height, and the color, are all based
       off of what github.com does when displaying markdown. */
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
                 Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
                 "Segoe UI Symbol";
    font-size: 16pt;
    line-height: 1.5;
    color: #24292e;
}

/* Code snippets are only as wide as their content. */
pre {
    display: table;
    width: 100%;
}

/* Make the background of code look different from surrounding text. */
code {
    background: #F0F0F0
}

p, .navigation-bar, table.posts, ul, ol {
    width: 100%;
}

table.posts {
    width: 100%;
	font-size: 16pt;
    line-height: 2;
}

table.posts &gt; tbody &gt; tr:nth-child(even) {
  background-color: #eee6ff
}

div.table-of-contents {
    font-size: 14pt;
}

img.thumbnail {
    width: 700px;
}

.series-navigation {
    width: 100%;
    font-size: 12pt;
    text-align: center;
    margin-bottom: 20px;
}

.series-navigation-header {
    font-weight: bold;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
}

.series-navigation-links {
    width: 100%;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
    flex-wrap: wrap;
}

.series-page-item .series-navigation-header {
  background-color: #eee6ff
}

.navigation-bar {
    width: 100%;
    font-size: 14pt;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
  }
</style><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#f0f0f0}.hljs,.hljs-subst{color:#444}.hljs-comment{color:#888}.hljs-attribute,.hljs-doctag,.hljs-keyword,.hljs-meta-keyword,.hljs-name,.hljs-selector-tag{font-weight:700}.hljs-deletion,.hljs-number,.hljs-quote,.hljs-selector-class,.hljs-selector-id,.hljs-string,.hljs-template-tag,.hljs-type{color:#800}.hljs-section,.hljs-title{color:#800;font-weight:700}.hljs-link,.hljs-regexp,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-symbol,.hljs-template-variable,.hljs-variable{color:#bc6060}.hljs-literal{color:#78a960}.hljs-addition,.hljs-built_in,.hljs-bullet,.hljs-code{color:#397300}.hljs-meta{color:#1f7199}.hljs-meta-string{color:#4d99bf}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><title>Callbacks (Part 2)</title>
</head>

<body>

<div class="navigation-bar">
    <a href="/posts.html">Posts</a>
    <a href="/series.html">Series</a>
    <a href="https://github.com/dgoffredo">About</a>
    <a href="https://github.com/dgoffredo/dgoffredo.github.io">Code</a>
</div>


<p>Sunday, March  18, 2018</p>

<div class="table-of-contents"><ul><li><a href="#callbacks_part_2">Callbacks (Part 2)</a><ul><li><a href="#injecting_a_default">Injecting a Default</a></li><li><a href="#writing_the_forwarding_implementation">Writing the Forwarding Implementation</a></li></ul></li></ul></div>

<h1 id="callbacks_part_2">Callbacks (Part 2)</h1>
<p><a href="callbacks.html">Previously</a> I described an API for submitting a query asynchronously
in such a way that the caller provides the object into which the query results
are written, but without having to specify an object factory.  It looked like
this:</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseAccessor</span> {</span>

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Results&gt;
    <span class="hljs-keyword">using</span> Callback = 
        std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">const</span> std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(Results&amp;)&gt;&amp;)&gt;;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Results&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">asyncQuery</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string_view&amp;  query,
                    <span class="hljs-keyword">const</span> Callback&lt;Results&gt;&amp; callback)</span></span>;
};
</code></pre>
<p>For brevity, let's define a couple of macros<a id="macros"></a>:</p>
<pre><code class="hljs">#define FN(<span class="hljs-params">...</span>) std<span class="hljs-type">::function</span>&lt;<span class="hljs-literal">void</span>(__VA_ARGS__)&gt;
#define CB(<span class="hljs-params">...</span>) const FN(__VA_ARGS__)&amp;
</code></pre>
<p>So we have:</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseAccessor</span> {</span>

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Results&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">asyncQuery</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string_view&amp;  query,
                    CB(CB(Results&amp;)          callback);
};
</span></span></code></pre>
<p>What if, in addition to producing result sets, this database API also has a
concept of output parameters?  These are like query parameters, except that
their values are overwritten by the query rather than used in it.</p>
<p>We could define an overload of <code>DatabaseAccessor::asyncQuery</code> that takes a
callback with an amended signature:</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseAccessor</span> {</span>

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Results&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">asyncQuery</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string_view&amp;  query,
                    CB(CB(Results&amp;)          callback);

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Results, <span class="hljs-keyword">typename</span> OutputParameters&gt;
    <span class="hljs-keyword">void</span> asyncQuery(<span class="hljs-keyword">const</span> std::string_view&amp;            query,
                    CB(CB(Results&amp;, OutputParameters&amp;) callback);
};
</span></span></code></pre>
<p>If the user wants output parameters, then he provides a callback that fits
the second signature, while if he doesn't want output parameters, he specifies
a callback that fits the first signature.</p>
<h2 id="injecting_a_default">Injecting a Default</h2>
<p>Most users don't want output parameters.  They're a strange concept in
databases, they can always be replaced by multiple result sets instead, and
Microsoft SQL Server is the only database I've worked with that has them.  It
would be ideal to appropriate as little code in our library to support them as
possible.</p>
<p>To this end, observe that since this library deduces the structure of its
output from the types of the output parameters (using <a href="https://bloomberg.github.io/bde/group__bdlat.html">this</a>), to omit
the <code>OutputParameters</code> argument is the same as if you specified one, but one
whose structure describes the absence of data: an "empty sequence."</p>
<p>In other words, if you don't specify the <code>OutputParameters</code>, the library knows
to expect no output parameters from the query.  Also, though, if you specify
an <code>OutputParameters</code> that has no members, the library knows to expect no
output parameters.</p>
<p>So, let's define a helper type, <code>EmptySequence</code>, that has no members and
introspection into which indicates "nothing to put here."  Then the first
overload of <code>DatabaseAccessor::asyncQuery</code> can be written in terms of the
second, "as if" the user had specified an <code>EmptySequence</code> for
<code>OutputParameters</code> rather than not specifying that argument at all.</p>
<p>How do you write this?  I find it very tricky to think about.</p>
<h2 id="writing_the_forwarding_implementation">Writing the Forwarding Implementation</h2>
<p>Let's look at the code again:</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseAccessor</span> {</span>

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Results&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">asyncQuery</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string_view&amp;  query,
                    CB(CB(Results&amp;)          callback);

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Results, <span class="hljs-keyword">typename</span> OutputParameters&gt;
    <span class="hljs-keyword">void</span> asyncQuery(<span class="hljs-keyword">const</span> std::string_view&amp;            query,
                    CB(CB(Results&amp;, OutputParameters&amp;) callback);
};
</span></span></code></pre>
<p>We want to implement the first in terms of the second using the <code>EmptySequence</code>
type for the dummy <code>OutputParameters</code>.</p>
<pre><code class="hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Results&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DatabaseAccessor::asyncQuery</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string_view&amp; query,
                                  CB(CB(Results&amp;)         callback)
{
    asyncQuery(query, <span class="hljs-comment">/* ? */</span>);
}
</span></span></code></pre>
<p>The difference, of course, is in the second argument of each <code>asyncQuery</code>
overload.  We're given a function that takes a function that takes a
<code>Results&amp;</code>, and we need to call the overload that takes a function that takes
a function that takes a <code>Results&amp;</code> and an <code>EmptySequence&amp;</code>, and we must
additionally see to it that the <code>EmptySequence&amp;</code> refers to some (dummy)
instance.</p>
<p>One way to think about this is that we need a function, <code>injectDummy</code>, that
maps one type of function into another type of function:</p>
<pre><code class="hljs">template &lt;typename Results&gt;
void DatabaseAccessor::<span class="hljs-built_in">asyncQuery</span>(const std::string_view&amp; query,
                                  <span class="hljs-built_in">CB</span>(<span class="hljs-built_in">CB</span>(Results&amp;)         callback)
{
    <span class="hljs-built_in">asyncQuery</span>(query, <span class="hljs-built_in">injectDummy</span>(callback));
}
</code></pre>
<p>where <code>injectDummy</code> has the following signature:</p>
<pre><code class="hljs">template &lt;typename Results&gt;
<span class="hljs-function"><span class="hljs-keyword">FN</span>(<span class="hljs-params">CB(<span class="hljs-params">Results&amp;, EmptySequence&amp;</span>)</span>) <span class="hljs-title">injectDummy</span>(<span class="hljs-params">CB(<span class="hljs-params">CB(<span class="hljs-params">Results&amp;</span>)</span>)</span>)</span>;
</code></pre>
<p>You might want to look again at what the <code>FN</code> and <code>CB</code> <a href="#macros">macros</a> mean.</p>
<p>You know that thing where when you have a cube drawn in two dimensions, you can
think of some of its corners as popping out of the page at you <em>or</em> as going
into the page, and if you do something weird in your mind you can switch back
and forth?</p>
<p>I feel like figuring out an answer to this C++ puzzle gave me a new sort of
facility along those lines.  Here's the implementation of <code>injectDummy</code> that I
came up with, written using lambda expressions:</p>
<pre><code class="hljs">template &lt;typename Results&gt;
<span class="hljs-function"><span class="hljs-keyword">FN</span>(<span class="hljs-params">CB(<span class="hljs-params">Results&amp;, EmptySequence&amp;</span>)</span>) <span class="hljs-title">injectDummy</span>(<span class="hljs-params">CB(<span class="hljs-params">CB(<span class="hljs-params">Results&amp;</span>)</span>) callback</span>)
</span>{
    <span class="hljs-keyword">return</span> [=](CB(Results&amp;, EmptySequence&amp;) innerCallback) {
        EmptySequence dummy;
        callback([&amp;](Results&amp; results) {
            innerCallback(results, dummy);
        });
    };
}
</code></pre>
<p>It's not complicated at all once it's written down.</p>
<p>I don't know enough Haskell to say whether there's a fancy name for this
operation, but it does feel a bit mathy, doesn't it?</p>
<p>So there we have it -- the no-output-parameters overload written in terms of 
the output-parameters overload:</p>
<pre><code class="hljs">template &lt;typename Results&gt;
<span class="hljs-function"><span class="hljs-keyword">FN</span>(<span class="hljs-params">CB(<span class="hljs-params">Results&amp;, EmptySequence&amp;</span>)</span>) <span class="hljs-title">injectDummy</span>(<span class="hljs-params">CB(<span class="hljs-params">CB(<span class="hljs-params">Results&amp;</span>)</span>) callback</span>)
</span>{
    <span class="hljs-keyword">return</span> [=](CB(Results&amp;, EmptySequence&amp;) innerCallback) {
        EmptySequence dummy;
        callback([&amp;](Results&amp; results) {
            innerCallback(results, dummy);
        });
    };
}

template &lt;typename Results&gt;
<span class="hljs-keyword">void</span> DatabaseAccessor::asyncQuery(<span class="hljs-keyword">const</span> std::string_view&amp; query,
                                  CB(CB(Results&amp;)         callback)
{
    asyncQuery(query, injectDummy(callback));
}
</code></pre>
<p>A colleague of mine called this "like the opposite of bind," or maybe it's an
inside-out bind.  Six lines of C++11 is what it is.</p>


<div class="series-navigation-placeholder"><div class="series-navigation"><div class="series-navigation-header">Callbacks</div><div class="series-navigation-links"><a href="callbacks.html">Part 1</a><span>Part 2</span></div></div></div>

<div class="navigation-bar">
    <a href="/posts.html">Posts</a>
    <a href="/series.html">Series</a>
    <a href="https://github.com/dgoffredo">About</a>
    <a href="https://github.com/dgoffredo/dgoffredo.github.io">Code</a>
</div>


</body>
</html>