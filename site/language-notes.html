<html>

<head>
  <meta charset="UTF-8" />

  <link rel="shortcut icon" type="image/x-icon" href="/site/favicon.ico" />

  
  <link rel="stylesheet" type="text/css" media="(orientation: landscape)" href="/site/landscape.css" />

  
  <link rel="stylesheet" type="text/css" media="(orientation: portrait)" href="/site/portrait.css" />

  <link rel="stylesheet" href="/highlightjs/styles/default.css" />

  
  <script src="/highlightjs/highlight.pack.js"> </script>

  <script>hljs.initHighlightingOnLoad();</script>

  <title>The Language That I Think I Want</title>
</head>

<body>

<div class="navigation-bar">
    <a href="/site/posts.html">Posts</a>
    <a href="/site/series.html">Series</a>
    <a href="https://github.com/dgoffredo">About</a>
    <a href="https://github.com/dgoffredo/dgoffredo.github.io">Code</a>
</div>


<p>Wednesday, April  15, 2020</p>

<div class="table-of-contents"><ul><li><a href="#the_language_that_i_think_i_want">The Language That I Think I Want</a><ul><li><a href="#observations">Observations</a></li><li><a href="#aims">Aims</a></li><li><a href="#tbd">TBD</a></li><li><a href="#conclusions">Conclusions</a></li></ul></li></ul></div>

<pre><code>(define sum
  (Î» (args ...)
    (+ args ...)))

(define (sum args ...)
  (+ args ...))

(define-as (list 1 2 third _ ...) (something "foo"))

{key value key2 value2}

[value value2 value3]

(let (foo bar
      baz buzz)
  whatever)

(match value
  pattern template
  pattern2 template2)
</code></pre>
<h1 id="the_language_that_i_think_i_want">The Language That I Think I Want</h1>
<ul>
<li>but probably don't</li>
<li>and certainly don't need</li>
</ul>
<p>I'm one of those nerds who likes to opine about programming languages.</p>
<p>From an industry perspective, it's an all-too-common Big Waste of Time, but boy
is it fun.  It's like having strong opinions about fonts, except that the
fonts can move mountains.  Digital mountains, of course.</p>
<h2 id="observations">Observations</h2>
<ul>
<li>Scheme is all anybody needs, but it sucks to always start from scratch</li>
<li>C is all anybody needs, but it sucks to always start from scratch</li>
<li>Go is all anybody needs, but it sucks to always start from scratch<ul>
<li>Well, that's not so fair.  Go has a useful standard library.</li>
<li>I know that complaining about the lack of generics is a cliche<ul>
<li>but come on!</li>
<li>won't even compare lists, that's where I draw the line</li>
</ul>
</li>
</ul>
</li>
<li>Maybe I should try OCaml.  They've been telling me for years...</li>
<li>Programming languages grow in scope and complexity as they age<ul>
<li>embrace it, simplicitly is dead!</li>
<li>maybe FORTRAN '22 <em>should</em> have built-in SMTP.  Might be useful!</li>
</ul>
</li>
</ul>
<h2 id="aims">Aims</h2>
<p>The <em>reason</em> for this exercise is to end up at:</p>
<pre><code>$ mkdir solveproblem
$ cd solveproblem
$ vim somefile.language
[... write a small amount of non-arcane code ...]
$ sometool
$ ./solveproblem
$ xdg-open beer
</code></pre>
<p>Maybe you're thinking "Perl."  I'm thinking more of something:</p>
<ul>
<li>Like Scheme, but borrowing some conveniences from Clojure:<ul>
<li>literal data structures (vectors, lists, dictionaries, sets)</li>
<li>immutable by default</li>
<li>fewer parentheses</li>
<li>no cons cells</li>
<li><strong>functions act on interfaces, not on concrete types</strong></li>
</ul>
</li>
<li>Scheme is so good because regular syntax, homoiconic, programmable...<ul>
<li>... blah blah BLAH DRINK THIS KOOL-AID</li>
<li>let's be honest, we're just doing this for the parentheses</li>
<li>so smooth, aesthetically pleasing, perfectly balanced, very nice</li>
</ul>
</li>
<li>More pattern matching:<ul>
<li>in function definitions, let bindings</li>
<li>like ES6 destructuring, but with Scheme's pattern matching</li>
</ul>
</li>
<li>File system based packages, maybe something like in Python<ul>
<li>no special <code>tool init</code>, no special <code>.module</code>, etc.</li>
</ul>
</li>
<li>Reduced variety of primitive types<ul>
<li>only one type of number (decimal!), one text encoding, no char</li>
<li>scary compatibility and performance implications, YOLO!</li>
</ul>
</li>
<li>Hygienic macro system, maybe something like Racket's syntax-parse</li>
<li>"Batteries included" library support, e.g.:<ul>
<li>POSIX equivalents (a lot: file systems, sockets, clock, poll, etc.)</li>
<li>Python-compatible regular expressions</li>
<li>random number generation</li>
<li>... maybe what I want is just <a href="https://docs.hylang.org/en/stable/">Hy</a> :)<ul>
<li>or <a href="https://github.com/anmonteiro/lumo">ClojureScript on node</a>?<ul>
<li>I'll do a project in those languages first...</li>
</ul>
</li>
</ul>
</li>
<li>command line parsing</li>
<li>all the algorithms (e.g. STL)</li>
<li>database inter-op</li>
<li>sqlite (life is too short not to have sqlite)</li>
</ul>
</li>
<li>a simple, non-opaque system for record types and interfaces<ul>
<li>maybe like Go, or maybe just use duck typing (like Python)</li>
<li>Crockford's "class-free object oriented programming" is tempting,
except that I think a checked interface (whether dynamic or static)
is beneficial enough to be part of the language.</li>
</ul>
</li>
<li>date/time and time zones that just work and don't let you get it wrong<ul>
<li>ISO-8601 built in</li>
</ul>
</li>
<li>built-in concurrency<ul>
<li>Go's approach is so compelling, I think that's the way</li>
<li>might be better suited as a library, like Guile's fibers.  Not sure.<ul>
<li>oh yeah, and if we do CSP, let it be based on CML</li>
</ul>
</li>
</ul>
</li>
<li>macros or special syntax for comprehensions<ul>
<li>Racket's <code>(for/list ...)</code>  is pretty good.  Maybe even more concise.</li>
<li>hard to do better than Python or Haskell style comprehensions</li>
</ul>
</li>
</ul>
<h2 id="tbd">TBD</h2>
<ul>
<li>How much like Scheme with regard to control flow?<ul>
<li>call/cc?</li>
<li>dynamic-unwind?</li>
<li>maybe something more like exceptions?</li>
<li>or maybe errors as values? (e.g. Go)</li>
<li>or maybe dedicated error syntax as <em>part</em> of the call syntax?<ul>
<li>what could that look like?</li>
</ul>
</li>
</ul>
</li>
<li>assertions?</li>
<li>foreign function interface?</li>
<li>"unsafe" library? (for memory access, syscalls, etc. a la Go)</li>
</ul>
<h2 id="conclusions">Conclusions</h2>
<ul>
<li>There's nothing new here, really.</li>
<li>This synthesis is probably not going to produce anything substantially
better than what's currently available, except that it will all fit in
my head (and nobody else's).</li>
<li>Maybe I should just pick a subset of Racket and write in that<ul>
<li>or, HEY, I could implement all of this as a Racket <code>#lang</code></li>
<li>that'd be a worthwhile exercise all on its own</li>
<li>ðŸ¤©</li>
<li>it's the <a href="http://winestockwebdesign.com/Essays/Lisp_Curse.html">lisp curse</a>!</li>
</ul>
</li>
</ul>


<div class="series-navigation-placeholder" />

<div class="navigation-bar">
    <a href="/site/posts.html">Posts</a>
    <a href="/site/series.html">Series</a>
    <a href="https://github.com/dgoffredo">About</a>
    <a href="https://github.com/dgoffredo/dgoffredo.github.io">Code</a>
</div>


</body>
</html>