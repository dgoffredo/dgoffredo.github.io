<html>
<head>
  <meta charset="UTF-8"></meta>

  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"></link>

  
  <style media="(orientation: landscape)">body {
    /* Limiting the width (see p below), the chosen font, the line height, and
       the color, are all based off of what github.com does when displaying
       markdown. */
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
                 Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
                 "Segoe UI Symbol";
    font-size: 16pt;
    line-height: 1.5;
    color: #24292e;
}

/* Code snippets are only as wide as their content. */
pre {
    display: table;
    min-width: 700;
}

/* Make the background of code look different from surrounding text. */
code {
    background: #F0F0F0
}

p, .navigation-bar, table.posts, ul, ol {
    max-width: 700;
}

table.posts {
    width: 100%;
	font-size: 16pt;
    line-height: 2;
}

table.posts &gt; tbody &gt; tr:nth-child(even) {
  background-color: #eee6ff
}

div.table-of-contents {
    font-size: 14pt;
}

img.thumbnail {
    width: 700px;
}

.series-navigation {
    width: 100%;
    font-size: 12pt;
    max-width: 700px;
    text-align: center;
    margin-bottom: 20px;
}

.series-navigation-header {
    font-weight: bold;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
}

.series-navigation-links {
    width: 100%;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
    flex-wrap: wrap;
}

.series-page-item .series-navigation-header {
  background-color: #eee6ff
}

.navigation-bar {
    width: 100%;
    font-size: 14pt;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
  }
</style><style media="(orientation: portrait)">body {
    /* The chosen font, the line height, and the color, are all based
       off of what github.com does when displaying markdown. */
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
                 Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
                 "Segoe UI Symbol";
    font-size: 16pt;
    line-height: 1.5;
    color: #24292e;
}

/* Code snippets are only as wide as their content. */
pre {
    display: table;
    width: 100%;
}

/* Make the background of code look different from surrounding text. */
code {
    background: #F0F0F0
}

p, .navigation-bar, table.posts, ul, ol {
    width: 100%;
}

table.posts {
    width: 100%;
	font-size: 16pt;
    line-height: 2;
}

table.posts &gt; tbody &gt; tr:nth-child(even) {
  background-color: #eee6ff
}

div.table-of-contents {
    font-size: 14pt;
}

img.thumbnail {
    width: 700px;
}

.series-navigation {
    width: 100%;
    font-size: 12pt;
    text-align: center;
    margin-bottom: 20px;
}

.series-navigation-header {
    font-weight: bold;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
}

.series-navigation-links {
    width: 100%;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
    flex-wrap: wrap;
}

.series-page-item .series-navigation-header {
  background-color: #eee6ff
}

.navigation-bar {
    width: 100%;
    font-size: 14pt;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
  }
</style><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#f0f0f0}.hljs,.hljs-subst{color:#444}.hljs-comment{color:#888}.hljs-attribute,.hljs-doctag,.hljs-keyword,.hljs-meta-keyword,.hljs-name,.hljs-selector-tag{font-weight:700}.hljs-deletion,.hljs-number,.hljs-quote,.hljs-selector-class,.hljs-selector-id,.hljs-string,.hljs-template-tag,.hljs-type{color:#800}.hljs-section,.hljs-title{color:#800;font-weight:700}.hljs-link,.hljs-regexp,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-symbol,.hljs-template-variable,.hljs-variable{color:#bc6060}.hljs-literal{color:#78a960}.hljs-addition,.hljs-built_in,.hljs-bullet,.hljs-code{color:#397300}.hljs-meta{color:#1f7199}.hljs-meta-string{color:#4d99bf}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><title>Message Queue Blues</title>
</head>

<body>

<div class="navigation-bar">
    <a href="/posts.html">Posts</a>
    <a href="/series.html">Series</a>
    <a href="/mailinglist.html">Mailing List</a>
    <a href="https://github.com/dgoffredo">About</a>
    <a href="https://github.com/dgoffredo/dgoffredo.github.io">Code</a>
</div>




<div class="table-of-contents"></div>

<h1>Message Queue Blues</h1>
<p>Imagine a portable, local, available, and minimal message queue: like a file or
a socket, but instead of reading from or writing to it, or receiving from or
sending to it, you enqueue to and dequeue from it.  You are not the first
person to imagine such a thing.  There are several ways to do it, but first
some requirements.</p>
<h2>Requirements</h2>
<p>Here's what I'm looking for.</p>
<h3>Portable</h3>
<p>This message queue needs to work on any UNIX-like system (sorry, Microsoft):
Linux, BSD variants, OS X, HP-UX, Solaris, and AIX at least.  Practically this
means that it must use only those facilities in POSIX.  Additionally, the queue
must be accessible from a variety of programming languages and environments
without much adaptation effort.  Ideally this means a file-like interface.</p>
<h3>Local</h3>
<p>The queue does not need to be accessible outside of the machine in which it was
created.  I'm looking for a system-persistent (possibly gone on restart) IPC
mechanism.</p>
<h3>Available</h3>
<p>The queue cannot depend on the operation of a singleton daemon (such as a
broker process in <code>init.d</code>), and must be available as soon as process Id 1 can
fork, possibly with the additional requirement that a file system is mounted.
This rules out things like Redis, RabbitMQ, and ZeroMQ.</p>
<h3>Minimal</h3>
<p>Any source code above the system level must be short enough to read and
understand in one sitting, and trivial to build and deploy with default
development tools (e.g. no CMake, non-default compilers or libraries, etc.).</p>
<h2>Implementation Options</h2>
<p>A few possible solutions to this problem come to mind.  There are no doubt
others, but here's what I considered.</p>
<h3>Regular File with File Locking and Polling</h3>
<p>Just use sqlite!  Job done, right?  Almost.  Sqlite (or any other regular-file-
based IPC) requires a writer to hold a lock; nobody else can write <em>or read</em>
when the lock is held by a writer.</p>
<p>Technically, using sqlite would violate the <em>minimal</em> requirement, above,
because you can't read and understand it all in one sitting.  However, it's
tempting to use because it works out of the box with python, can be dropped
into any C/C++ build with a single <code>.c</code> file, and has bindings to many other
languages.</p>
<p>So how might you implement a queue this way?  First attempt -- a database
containing a single table "Queue":</p>
<pre><code class="hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Queue(
    Id      <span class="hljs-type">integer</span> <span class="hljs-keyword">primary</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,
    Message text                <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>);
</code></pre>
<p>For example:</p>
<pre><code class="hljs">Id      Message                
<span class="hljs-params">---</span>     <span class="hljs-params">-------</span>                
1       <span class="hljs-string">"I was enqueued first."</span>
2       <span class="hljs-string">"Then I was enqueued."</span> 
3       <span class="hljs-string">"I am most recent."</span>    
</code></pre>
<p>That's ID as in "identity," not the word "id."  Then a dequeue looks like this:</p>
<pre><code class="hljs"><span class="hljs-keyword">begin</span> <span class="hljs-keyword">immediate</span> <span class="hljs-keyword">transaction</span>;
</code></pre>
<p>followed by</p>
<pre><code class="hljs"><span class="hljs-keyword">select</span> Id, Message <span class="hljs-keyword">from</span> Queue <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> Id <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>;
</code></pre>
<p>If we get something, then we have to remove it from the queue:</p>
<pre><code class="hljs"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> Queue <span class="hljs-keyword">where</span> Id <span class="hljs-operator">=</span> <span class="hljs-variable">@Id</span>;
</code></pre>
<p>and in either case finish the transaction:</p>
<pre><code class="hljs"><span class="hljs-keyword">commit</span> <span class="hljs-keyword">transaction</span>;
</code></pre>
<p>In this scheme, if the queue is empty, our only recourse is to commit the
transaction, sleep a bit, and then try again.  A more complicated protocol
could get around this, so that a dequeuer is notified when a message is
available for it.  I discuss this in another section.</p>
<p>The enqueue operation is simpler:</p>
<pre><code class="hljs"><span class="hljs-selector-tag">begin</span> <span class="hljs-selector-tag">immediate</span> <span class="hljs-selector-tag">transaction</span>;
<span class="hljs-selector-tag">insert</span> <span class="hljs-selector-tag">into</span> <span class="hljs-selector-tag">Queue</span>(Message) <span class="hljs-selector-tag">values</span>(<span class="hljs-variable">@Message</span>);
<span class="hljs-selector-tag">commit</span> <span class="hljs-selector-tag">transaction</span>;
</code></pre>
<p>Not so hard, right?  But there are problems:</p>
<ol>
<li><p>Polling sucks.</p>
</li>
<li><p>There's no concept of fairness in which dequeuer gets the next message.</p>
</li>
<li><p>Sqlite's lock-the-world strategy could starve enqueuers or dequeuers, and
will slow to a crawl under high contention.</p>
</li>
</ol>
<p>Still, if the numbers of enqueuers, dequeuers, and messages are low, and if
there are ready-made bindings to sqlite available for your languauages of
choice, then this is a viable option.</p>
<p>It has the added benefit that the queue is persistent across system restart,
so long as the database file is on a persistent drive.</p>
<h3>Regular File with File Locking and Notification Pipes</h3>
<p>For the price of added complexity, we can remove polling from the sqlite-based
local message queue.  The idea is that when a dequeuer sees that the queue is
empty, it adds itself to a list of waiting dequeuers, identifying itself using
a path to a pipe (fifo) that it has open for reading.</p>
<p>Then _en_queuers have the added responsibility on enqueue of checking whether
the queue is currently empty.  If it is, then in addition to enqueueing their
message they must also remove the oldest waitlist record, open the associated
pipe for writing, but <em>non-blocking</em> so that they can detect if the dequeuer is
no longer waiting, write the ID of the message or the message itself to the
pipe, and then close the pipe.</p>
<p>There are all sorts of problems with this way of doing it, but it does
eliminate polling.  A lock is taken on the database file exactly once per
enqueue and at most once per dequeue.</p>
<h3>UNIX Domain Socket with Client-Provided Server</h3>
<p>I said in the requirements section that solutions like ZeroMQ were inadequate
because they require a dedicated process to act as the broker or keeper of the
queue.</p>
<p>There is a way around this, though.  You can decentralize the responsibility of
spawning a broker at the cost of complicating what clients of the message queue
must do to access it.  Here's how:</p>
<p>Associate a UNIX domain socket with the message queue.  When a client wants to
enqueue or dequeue, he tries to connect to the socket.  If that fails, he
deletes the socket, fork/exec a known program, e.g.
<code>/usr/bin/local-queue-broker</code>, passing it the path to the (deleted) domain
socket.  <code>local-queue-broker</code> will try to bind and listen on the socket.  If it
succeeds, then it continues to execute as the broker of the message queue.  If
it fails, then it exits.  The parent process, meanwhile, keeps trying to
connect, sleeping briefly between each failure.</p>
<p>When a broker is not running, clients will race to delete the socket, and then
their broker child processes will race to listen on the socket.  One broker
will win, and this will be the new broker.  In this way, clients can coordinate
the establishment or reestablishment of a broker.</p>
<p>But what a pain in the ass.</p>
<h3>Shared Memory</h3>
<p>TODO (mention <a href="https://github.com/boostorg/interprocess/blob/develop/include/boost/interprocess/ipc/message_queue.hpp">boost/interprocess/ipc/message_queue</a>)</p>
<h3>POSIX Message Queues</h3>
<p>TODO An introduction that sets up the next section.</p>
<h2>POSIX Message Queues</h2>
<p>TODO All of the pain.</p>
<h2>Signals and System Calls</h2>
<p>TODO The nitty gritty.</p>
<h2>Using The Message Queue from Guile</h2>
<p>TODO Some scheme code.</p>
<h2>Code</h2>
<p>TODO Mention the <code>mq</code> repository.</p>


<div class="series-navigation-placeholder"></div>

<div class="navigation-bar">
    <a href="/posts.html">Posts</a>
    <a href="/series.html">Series</a>
    <a href="/mailinglist.html">Mailing List</a>
    <a href="https://github.com/dgoffredo">About</a>
    <a href="https://github.com/dgoffredo/dgoffredo.github.io">Code</a>
</div>


</body>
</html>