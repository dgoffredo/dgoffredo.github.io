#!/usr/bin/env python3

"""create a simple blog from markdown files

From within this kind of directory structure:

    ./content/
              grinds-my-gears.md
              gear.png
              happy_new_year.md
              not_a_post.md
   
    ./config/
             navigate.html
             style.css

    ./posts/
            2018-01-01  -> ../content/happy_new_year.md
            2018-01-05  -> ../content/grinds-my-gears.md

    ./site/

Run this script in `./` to generate HTML files and symlinks in the `./site/`
directory derived from or pointing to files in `./content`.

The result will be

    ./content/
              grinds-my-gears.md
              gear.png
              happy_new_year.md
              not_a_post.md
   
    ./config/
             navigate.html
             style.css

    ./posts/
            2018-01-01  ->  ../content/happy_new_year.md
            2018-01-05  ->  ../content/grinds-my-gears.md

    ./site/
           grinds-my-gears.html
           gear.png  ->  ../content/gear.png
           happy_new_year.html
           not_a_post.html
           posts.html
           index.html  ->  ./grinds-my-gears.html
"""

import mistune
import linkify
import pathutil
import series
import tableofcontents

from datetime import datetime
import os
from pathlib import Path
from xml.etree import ElementTree as ET

# Note that this is actually XML.  I omit the XHTML-required "!DOC" stuff,
# though, because I found that it caused browsers to ignore CSS's max-width
# style.
html_template = '''
<html>
<!-- Note that this is actually XML. I omit the XHTML-required "!DOC" stuff,
     though, because I found that it caused browsers to ignore CSS's max-width
     style. -->
<head>
  <meta charset="UTF-8" />

  <link rel="shortcut icon" type="image/x-icon" href="/site/favicon.ico" />

  <!-- style for landscape orientation, e.g. desktop browser -->
  <link rel="stylesheet" type="text/css"
      media="(orientation: landscape)"
      href="/site/landscape.css" />

  <!-- style for portrait orientation, e.g. mobile browser -->
  <link rel="stylesheet" type="text/css"
      media="(orientation: portrait)"
      href="/site/portrait.css" />

  <link rel="stylesheet" href="/highlightjs/styles/default.css" />

  <!-- The space character prevents etree from omitting the closing tag. -->
  <script src="/highlightjs/highlight.pack.js"> </script>

  <script>hljs.initHighlightingOnLoad();</script>

  <title>{title}</title>
</head>

<body>

{navigate}

{date}

{table_of_contents}

{content}

{series_navigation}

{navigate}

</body>
</html>
'''

def get_first_h1(html_markup):
    begin = html_markup.find('<h1>') + len('<h1>')
    if begin == -1:
        return None
    end = html_markup.find('</h1>', begin)
    if end == -1:
        return None

    return html_markup[begin:end]

_markdown_converter = mistune.Markdown(use_xhtml=True)

def markdown2html(markdown_path):
    "Return a string containing the HTML output of compiling markdown."
    
    return _markdown_converter(markdown_path.read_text())
      
def pretty_date(date):
    day_of_week_and_month_name = date.strftime('%A, %B ')
    return f'{day_of_week_and_month_name} {date.day}, {date.year}'

def create_page(from_path, to_path, navigate, series_by_date, date=None):
    """Write HTML to the specified `to_path` from the markdown at the specified
    `from_path`, the specified `navigate` HTML, and the optionally specified
    `date` object.  Return the title of the generated HTML document."""

    with to_path.open('w', encoding='utf8') as destination:
        content = markdown2html(from_path)
        title = get_first_h1(content)
        date_paragraph = '<p>' + pretty_date(date) + '</p>' if date is not None else ''
        title = title if title is not None else ''
        toc = '<div class="table-of-contents"></div>'
        series_navigation = '<div class="series-navigation-placeholder"></div>'
        html = html_template.format(title=title,
                                    navigate=navigate,
                                    date=date_paragraph,
                                    table_of_contents=toc,
                                    content=content,
                                    series_navigation=series_navigation)
        html = ET.fromstring(html)

        if date:
            # This is a post, so expand the table of contents.
            tableofcontents.insert_table_of_contents(html, max_depth=2)
 
        if date in series_by_date:
            # series.insert_series_navigation(html, Path('series/Russia and Czechia'), from_path)
            series.insert_series_navigation(html, series_by_date[date], from_path)
            
        # Wrap <img ...> tags in links of the img src is a *_small.jpg
        linkify.wrap_images(html, r'^(.*)_small\.jpg$', r'\1.jpg')

        ET.ElementTree(html).write(destination, encoding='unicode')

    return title

def create_series(series_by_date, site: Path, navigate):
    """Create site/series.html"""
    content = '<div class="series-navigation-placeholder"></div>'
    html = html_template.format(title='Series',
                                 navigate=navigate,
                                 date='',
                                 table_of_contents='',
                                 content=content,
                                 series_navigation='')
    html = ET.fromstring(html)
    
    # TODO: this stuff with `relative_to` is a hack
    relative_to = site.parent/'content'/'README.md'
    container = html.find('body').find("div[@class='series-navigation-placeholder']")
    
    # Go through series directories most-recently-updated first.
    # Visit each directory exactly once.
    dirs = set()
    series_dirs = [] # in order
    for date, dir in sorted(series_by_date.items(), key=lambda x: x[0], reverse=True):
        if dir in dirs:
            continue # already added this series
        dirs.add(dir)
        series_dirs.append(dir)

    for dir in series_dirs:
        wrapper = ET.TreeBuilder().start('div', {'class': 'series-page-item'})
        wrapper.append(series.series_navigation(dir, relative_to))
        container.append(wrapper)
        
    ET.ElementTree(html).write(site/'series.html', encoding='unicode')

def create_posts(posts_list, page_titles, site: Path, navigate):
    """Create site/posts.html"""
    content_template = '''
    <table class="posts">
      <tr><th align="left">Date</th><th align="right">Post</th></tr>
      {rows}
    </table>
    '''

    row_template = '''
      <tr><td align="left">{date}</td>
          <td align="right"><a href="{href}">{title}</a></td></tr>
    '''

    content_dir = Path('content').resolve()
    rows = [row_template.format(date=date,
                                href=str(path.relative_to(content_dir).with_suffix('.html')),
                                title=page_titles[path]) \
            for path, date in posts_list]

    content = content_template.format(rows='\n'.join(rows))

    with (site/'posts.html').open('w') as f:
        f.write(html_template.format(title='Posts',
                                     navigate=navigate,
                                     date='',
                                     table_of_contents='',
                                     content=content,
                                     series_navigation=''))

def generate(root):
    # `posts` is a directory of symbolic links to markdown files.
    # The name of each symbolic link is an ISO-8601 date.
    # `post_dates` maps the resolved paths of the markdown files
    # to the `datetime.Date` parsed from the name of the symbolic link.
    posts = root/'posts'
    post_dates = { 
        p.resolve(): datetime.strptime(p.name, "%Y-%m-%d").date() \
        for p in posts.iterdir() if p.is_symlink()
    }

    # TODO: consider moving this to `series.py`
    series = root/'series'
    series_by_date = {} # {<date>: <path to dir in series/>}
    for dir in filter(Path.is_dir, series.iterdir()):
        for link in filter(Path.is_symlink, dir.iterdir()):
            date = datetime.strptime(Path(os.readlink(link)).name, "%Y-%m-%d").date()
            series_by_date[date] = dir

    config = root/'config'
    content = root/'content'
    navigate = (config/'navigate.html').read_text()
    site = root/'site'
    (site/'landscape.css').symlink_to('../config/landscape.css')
    (site/'portrait.css').symlink_to('../config/portrait.css')

    page_titles = {}
 
    for file_path in content.rglob('*'):
        file_path = file_path.resolve()
        name      = file_path.name
        if name.startswith('.') or name.startswith('README'):
            # ignore "hidden" files (e.g. vim swap files) and README files.
            continue
        
        relative_path = file_path.relative_to(content)
        in_site = site/relative_path
        
        # Directories get a corresponding directory under site/
        if file_path.is_dir():
            if not in_site.exists():
                in_site.mkdir()
            continue

        extension = file_path.suffix.lower()
        # If it's not a markdown file, then just create a link to it in ./site
        if extension not in ('.md', '.markdown'):
            in_site.symlink_to(pathutil.up_to(in_site, root)/'content'/relative_path)
            continue

        # It's a markdown file, so generate HTML (with a date, if applicable).
        date = post_dates.get(file_path.resolve())
        html_path = in_site.with_suffix('.html')
        title = create_page(file_path,
                            html_path,
                            navigate,
                            series_by_date,
                            date)

        page_titles[file_path] = title

    # Most recent first [(full path, date) ...]
    posts_list = list(sorted(post_dates.items(),
                             key=lambda item: item[1],
                             reverse=True))

    recent_post_html_path = posts_list[0][0].relative_to(content).with_suffix('.html')
    
    redirect_template = (config/'redirect.template.html').read_text()
    # TODO: This double-redirect is not ideal.
    (site/'index.html').write_text(redirect_template.format(href=str(recent_post_html_path)))
    (root/'index.html').write_text(redirect_template.format(href=str('site/index.html')))

    create_posts(posts_list, page_titles, site, navigate)
    
    create_series(series_by_date, site, navigate)

if __name__ == '__main__':
    generate(Path.cwd())
