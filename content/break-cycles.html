<html>
<head>
  <meta charset="UTF-8" />

  <link href="../site/style.css" rel="stylesheet" type="text/css" />

  <title>Code Generation and the Minimum Feedback Arc Set</title>
</head>

<body>

<div>
  <table class="navigate">
    <tr>
      <td><a href="../site/posts.html">Posts</a></td>
      <td><a href="https://www.github.com/dgoffredo">About</a></td>
      <td>
        <a href="https://www.github.com/dgoffredo/dgoffredo.github.io">Code</a>
      </td>
    </tr>
  </table>
</div>




<div class="table-of-contents"><ul><li><a href="#code_generation_and_the_minimum_feedback_arc_set">Code Generation and the Minimum Feedback Arc Set</a><ul><li><a href="#generating_c_classes">Generating C++ Classes</a></li><li><a href="#larger_cycles">Larger Cycles</a></li></ul></li></ul></div>

<h1 id="code_generation_and_the_minimum_feedback_arc_set">Code Generation and the Minimum Feedback Arc Set</h1>

<p>I ran into a graph problem recently.</p>

<h2 id="generating_c_classes">Generating C++ Classes</h2>

<p>One day I'll write a <a href="https://github.com/bloomberg/bde/blob/master/groups/bdl/bdlat/doc/bdlat.txt">bdlat</a>-compatible C++ class
<a href="https://github.com/dgoffredo/bat-codegen">generator</a>. It will allow you to write things like <code>basic.bdlat</code>:</p>

<pre><code>(package basic

  (import core)

  (type Value
    "a generic value in a restricted type system"
    (choice
      ("integer"  core/integer)
      ("decimal"  core/decimal)
      ("string"   core/string)
      ("optional" (optional Value))
      ("array"    (array Value))))
</code></pre>

<p>and then do something like </p>

<pre><code>$ bat-codegen --language c++ --toplevel Lakos --component types basic.bdlat
</code></pre>

<p>to produce the files <code>basic_types.h</code> and <code>basic_types.cpp</code> containing the C++
class <code>Lakos::basic::Value</code>.</p>

<p>Here's a first shot at what the definition of <code>Lakos::basic::Value</code> might look
like:</p>

<pre><code>class Value {
    bdlb::Variant&lt;int64_t,
                  bdldfp::Decimal64,
                  bsl::string,
                  bdlb::NullableValue&lt;Value&gt;,
                  bsl::vector&lt;Value&gt; &gt; 
        d_data;

  public:
      // ...
};
</code></pre>

<p>We've already run into trouble. <code>Value</code>'s size depends on its own size. To work
around this, a level of indirection is needed. Suppose the class template
<code>Allocated&lt;T&gt;</code> were a wrapper around a heap-allocated <code>T</code> referred to by a
<code>T*</code>, but with value semantics rather than pointer semantics (i.e. copying the
<code>Allocated&lt;T&gt;</code> copies the referred to <code>T</code> instance). Then <code>Value</code> can be
defined as:</p>

<pre><code>class Value {
    bdlb::Variant&lt;int64_t,
                  bdldfp::Decimal64,
                  bsl::string,
                  bdlb::NullableValue&lt;Allocated&lt;Value&gt; &gt;,
                  bsl::vector&lt;Allocated&lt;Value&gt; &gt;
        d_data;

  public:
    // ...
};
</code></pre>

<p>That would work.</p>

<h2 id="larger_cycles">Larger Cycles</h2>

<p>When a type depends upon itself, it doesn't necessarily do so by having itself
as a member (as was nearly the case with <code>Value</code> above). It could be that the
type contains a type that contains the original type. Or it could be that the
type contains a type that contains a type that contains the original type, etc.</p>

<p>Generally, a type <code>A</code> <em>contains</em> a type <code>B</code> if any of the following is true:</p>

<ul>
<li><code>A</code> is a sequence or a choice having an element of type <code>B</code></li>
<li><code>A</code> is a sequence or a choice having an element of type <code>(optional B)</code></li>
<li><code>A</code> is a sequence or a choice having an element of type <code>(array B)</code></li>
</ul>

<p>We can think of a set of types as a directed graph where an edge points from
<code>A</code> to <code>B</code> if <code>A</code> <em>contains</em> <code>B</code>. Let's call such a directed graph a dependency
graph.</p>

<p>Then <code>A</code> <em>depends upon</em> <code>B</code> if <code>A</code> <em>contains</em> <code>B</code> or if <code>A</code> <em>contains</em> a <code>C</code>
where <code>C</code> <em>depends upon</em> <code>B</code>. That is, <code>A</code> <em>depends upon</em> <code>B</code> if there exists a
directed path from <code>A</code> to <code>B</code> in the dependency graph.</p>

<p>The graph for the types in <code>(package basic ...)</code>, above, looks like this:</p>

<p><img alt="dependency graph of &quot;Value&quot;" src="just-value.svg" title="" /></p>

<p>Not very interesting. But suppose it looked like this instead:</p>

<p><img alt="a more complicated dependency graph" src="cyclic.svg" title="" /></p>


<div>
  <table class="navigate">
    <tr>
      <td><a href="../site/posts.html">Posts</a></td>
      <td><a href="https://www.github.com/dgoffredo">About</a></td>
      <td>
        <a href="https://www.github.com/dgoffredo/dgoffredo.github.io">Code</a>
      </td>
    </tr>
  </table>
</div>


</body>
</html>