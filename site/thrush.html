<html>

<head>
  <meta charset="UTF-8" />

  <link href="../site/favicon.ico" rel="shortcut icon" type="image/x-icon" />

  <link href="../site/style.css" rel="stylesheet" type="text/css" />

  <link href="../highlightjs/styles/default.css" rel="stylesheet" />

  
  <script src="../highlightjs/highlight.pack.js"> </script>

  <script>hljs.initHighlightingOnLoad();</script>

  
  <script src="../site/linkify.js"> </script>

  <title>The Thrush Combinator</title>
</head>

<body>

<div>
  <table class="navigate">
    <tr>
      <td align="left">
        <a href="../site/posts.html">Posts</a>
      </td>
      <td align="center">
        <a href="https://www.github.com/dgoffredo">About</a>
      </td>
      <td align="right">
        <a href="https://www.github.com/dgoffredo/dgoffredo.github.io">Code</a>
      </td>
    </tr>
  </table>
</div>


<p>Tuesday, March  24, 2020</p>

<div class="table-of-contents"><ul><li><a href="#the_thrush_combinator">The Thrush Combinator</a></li></ul></div>

<h1 id="the_thrush_combinator">The Thrush Combinator</h1>
<pre><code class="lang-javascript">const thrush = (value, func, ...funcs) =&gt;
    func ? thrush(func(value), ...funcs) : value;
</code></pre>
<p>I was looking up how I've <a href="https://github.com/dgoffredo/llama/blob/master/bin/llama.js">previously</a> used <a href="https://requirejs.org/">requirejs</a> and noticed the
function definition above.</p>
<p>Some call this the <a href="https://www.google.com/search?q=thrush+combinator">thrush combinator</a>, though I don't know if it's really
a thing.  It has nothing to do with <a href="https://en.wikipedia.org/wiki/Linear_gingival_erythema">HIV</a>.</p>
<p>The idea is that you have an initial value on which you want to perform a
sequence of transformations.  For example, in a UNIX shell, you might write</p>
<pre><code class="lang-console">$ echo foobar | tr i x | sed 's/./\0\n/g' | sort | uniq -c | sort -rn | head -1
      2 o
</code></pre>
<p>In programming languages with function invocation syntax, you might write</p>
<pre><code class="lang-javascript">const result = finally_this(and_then_this(then_this(do_this(initial_data))))
</code></pre>
<p>The order in which those functions are applied reads right-to-left:</p>
<ol>
<li>You start with <code>initial_data</code>,</li>
<li>then you apply <code>do_this</code> to <code>initial_data</code>,</li>
<li>then you apply <code>then_this</code> to the result of (2),</li>
<li>then you apply <code>and_then_this</code> to the result of (3),</li>
<li>then you apply <code>finally_this</code> to the result of (4),</li>
<li>and then (5) is the answer.</li>
</ol>
<p><code>thrush</code> allows you to rewrite that expression in the following way:</p>
<pre><code class="lang-javascript">const result =
    thrush(initial_data, do_this, then_this, and_then_this, finally_this);
</code></pre>
<p>That looks more like the shell pipeline.  It also looks like a sequence of
statements in an imperative programming language, where there is an implicit
<a href="https://en.wikipedia.org/wiki/Sequence_point">sequence point</a> after each function invocation:</p>
<pre><code>declare initial_data;
do_this();
then_this();
and_then_this();
finally_this();
</code></pre>
<p>In programming languages with objects and methods, this is sometimes expressed
as a chain of method invocations and called a <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent interface</a>:</p>
<pre><code class="lang-javascript">const result =
    initial_data.do_this().then_this().and_then_this().finally_this();
</code></pre>
<p>That's often formatted vertically to give an imperative feel:</p>
<pre><code class="lang-javascript">const result =
    initialdata
    .do_this()
    .then_this()
    .and_then_this()
    .finally_this();
</code></pre>
<p>Clojure has a macro version of the thrush combinator, spelled <a href="https://en.wikipedia.org/wiki/Fluent_interface">-&gt;</a>, and
confusingly called the "threading macro":</p>
<pre><code class="lang-clojure">(def result
  (-&gt; initial-data do-this then-this and-then-this finally-this))
</code></pre>
<p>Getting back to the Javascript implementation from before:</p>
<pre><code class="lang-javascript">const thrush = (value, func, ...funcs) =&gt;
    func ? thrush(func(value), ...funcs) : value;
</code></pre>
<p>Isn't it cool how that works?  Maybe it's clearer with less syntax, in
<a href="https://racket-lang.org/">Racket</a>:</p>
<pre><code class="lang-scheme">(define (thrush value . funcs)
  (if (empty? funcs)
    value
    (apply thrush (cons ((first funcs) value) (rest funcs)))))
</code></pre>
<p>Yuck, that didn't help at all.  Maybe pattern matching will help.  How about
this?</p>
<pre><code class="lang-scheme">(define thrush
  (match-lambda*
    [(list value) value]
    [(list value func funcs ...) (thrush (func value) funcs ...)]))
</code></pre>
<p>Getting better?  Maybe it's clearer as a pattern matching <em>macro</em> instead of as
a function:</p>
<pre><code class="lang-scheme">(define-syntax thrush
  (syntax-rules ()
    [(thrush value) value]
    [(thrush value func funcs ...) (thrush (func value) funcs ...)]))
</code></pre>
<p>They're really very similar, aren't they?</p>
<p>This makes me wonder what a horrid affair this would be in C++.  Let's try it:</p>
<pre><code class="lang-c++">#include &lt;utility&gt;

template &lt;typename Value&gt;
Value thrush(Value&amp;&amp; value) {
    return std::forward&lt;Value&gt;(value);
}

template &lt;typename Value, typename Func, typename ... Funcs&gt;
auto thrush(Value&amp;&amp; value, Func&amp;&amp; func, Funcs&amp;&amp;... funcs) {
    return thrush(func(std::forward&lt;Value&gt;(value)),
                  std::forward&lt;Funcs&gt;(funcs)...);
}
</code></pre>
<p>The <code>auto</code> function with a deduced return type (i.e. without a trailing return
type) is a C++14 feature.  You know, if it weren't for the <code>std::forward</code>
noise, this would be nearly as clean as the Racket code.  Maybe we can omit the
<code>std::forward</code> calls and it will only matter sometimes.  What do I know?  Let's
see what that looks like:</p>
<pre><code class="lang-c++">#include &lt;utility&gt;

template &lt;typename Value&gt;
Value thrush(Value&amp;&amp; value) {
    return value;
}

template &lt;typename Value, typename Func, typename ... Funcs&gt;
auto thrush(Value&amp;&amp; value, Func&amp;&amp; func, Funcs&amp;&amp;... funcs) {
    return thrush(func(value), funcs...);
}
</code></pre>
<p>Hot damn!  What about using <code>class</code> instead of <code>typename</code>?</p>
<pre><code class="lang-c++">#include &lt;utility&gt;

template &lt;class Value&gt;
Value thrush(Value&amp;&amp; value) {
    return value;
}

template &lt;class Value, class Func, class ... Funcs&gt;
auto thrush(Value&amp;&amp; value, Func&amp;&amp; func, Funcs&amp;&amp;... funcs) {
    return thrush(func(value), funcs...);
}
</code></pre>
<p>That's pretty good.  The last thing I'd do is make the first overload <code>auto</code>,
even though it doesn't save us much.  It makes the two overloads more
consistent:</p>
<pre><code class="lang-c++">#include &lt;utility&gt;

template &lt;class Value&gt;
auto thrush(Value&amp;&amp; value) {
    return value;
}

template &lt;class Value, class Func, class ... Funcs&gt;
auto thrush(Value&amp;&amp; value, Func&amp;&amp; func, Funcs&amp;&amp;... funcs) {
    return thrush(func(value), funcs...);
}
</code></pre>
<p>Not too shabby.  Still can't beat Javascript, though.</p>
<pre><code class="lang-javascript">const thrush = (value, func, ...funcs) =&gt;
    func ? thrush(func(value), ...funcs) : value;
</code></pre>
<p>What about in <a href="https://golang.org/">Go</a>?  Forget it.</p>


<div>
  <table class="navigate">
    <tr>
      <td align="left">
        <a href="../site/posts.html">Posts</a>
      </td>
      <td align="center">
        <a href="https://www.github.com/dgoffredo">About</a>
      </td>
      <td align="right">
        <a href="https://www.github.com/dgoffredo/dgoffredo.github.io">Code</a>
      </td>
    </tr>
  </table>
</div>


</body>
</html>