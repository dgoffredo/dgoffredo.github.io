<html>
<head>
  <meta charset="UTF-8"></meta>

  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"></link>

  
  <style media="(orientation: landscape)">body {
    /* Limiting the width (see p below), the chosen font, the line height, and
       the color, are all based off of what github.com does when displaying
       markdown. */
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
                 Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
                 "Segoe UI Symbol";
    font-size: 16pt;
    line-height: 1.5;
    color: #24292e;
}

/* Code snippets are only as wide as their content. */
pre {
    display: table;
    min-width: 700;
}

/* Make the background of code look different from surrounding text. */
code {
    background: #F0F0F0
}

p, .navigation-bar, table.posts, ul, ol {
    max-width: 700;
}

table.posts {
    width: 100%;
	font-size: 16pt;
    line-height: 2;
}

table.posts &gt; tbody &gt; tr:nth-child(even) {
  background-color: #eee6ff
}

div.table-of-contents {
    font-size: 14pt;
}

img.thumbnail {
    width: 700px;
}

.series-navigation {
    width: 100%;
    font-size: 12pt;
    max-width: 700px;
    text-align: center;
    margin-bottom: 20px;
}

.series-navigation-header {
    font-weight: bold;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
}

.series-navigation-links {
    width: 100%;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
    flex-wrap: wrap;
}

.series-page-item .series-navigation-header {
  background-color: #eee6ff
}

.navigation-bar {
    width: 100%;
    font-size: 14pt;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
  }
</style><style media="(orientation: portrait)">body {
    /* The chosen font, the line height, and the color, are all based
       off of what github.com does when displaying markdown. */
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
                 Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
                 "Segoe UI Symbol";
    font-size: 16pt;
    line-height: 1.5;
    color: #24292e;
}

/* Code snippets are only as wide as their content. */
pre {
    display: table;
    width: 100%;
}

/* Make the background of code look different from surrounding text. */
code {
    background: #F0F0F0
}

p, .navigation-bar, table.posts, ul, ol {
    width: 100%;
}

table.posts {
    width: 100%;
	font-size: 16pt;
    line-height: 2;
}

table.posts &gt; tbody &gt; tr:nth-child(even) {
  background-color: #eee6ff
}

div.table-of-contents {
    font-size: 14pt;
}

img.thumbnail {
    width: 700px;
}

.series-navigation {
    width: 100%;
    font-size: 12pt;
    text-align: center;
    margin-bottom: 20px;
}

.series-navigation-header {
    font-weight: bold;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
}

.series-navigation-links {
    width: 100%;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
    flex-wrap: wrap;
}

.series-page-item .series-navigation-header {
  background-color: #eee6ff
}

.navigation-bar {
    width: 100%;
    font-size: 14pt;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
  }
</style><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#f0f0f0}.hljs,.hljs-subst{color:#444}.hljs-comment{color:#888}.hljs-attribute,.hljs-doctag,.hljs-keyword,.hljs-meta-keyword,.hljs-name,.hljs-selector-tag{font-weight:700}.hljs-deletion,.hljs-number,.hljs-quote,.hljs-selector-class,.hljs-selector-id,.hljs-string,.hljs-template-tag,.hljs-type{color:#800}.hljs-section,.hljs-title{color:#800;font-weight:700}.hljs-link,.hljs-regexp,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-symbol,.hljs-template-variable,.hljs-variable{color:#bc6060}.hljs-literal{color:#78a960}.hljs-addition,.hljs-built_in,.hljs-bullet,.hljs-code{color:#397300}.hljs-meta{color:#1f7199}.hljs-meta-string{color:#4d99bf}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><title>The Thrush Combinator</title>
</head>

<body>

<div class="navigation-bar">
    <a href="/posts.html">Posts</a>
    <a href="/series.html">Series</a>
    <a href="/mailinglist.html">Mailing List</a>
    <a href="https://github.com/dgoffredo">About</a>
    <a href="https://github.com/dgoffredo/dgoffredo.github.io">Code</a>
</div>


<p>Tuesday, March  24, 2020</p>

<div class="table-of-contents"><ul><li><a href="#the_thrush_combinator">The Thrush Combinator</a></li></ul></div>

<h1 id="the_thrush_combinator">The Thrush Combinator</h1>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">const</span> thrush = <span class="hljs-function">(<span class="hljs-params">value, func, ...funcs</span>) =&gt;</span>
    func ? thrush(func(value), ...funcs) : value;
</code></pre>
<p>I was looking up how I've <a href="https://github.com/dgoffredo/llama/blob/master/bin/llama.js">previously</a> used <a href="https://requirejs.org/">requirejs</a> and noticed the
function definition above.</p>
<p>Some call this the <a href="https://www.google.com/search?q=thrush+combinator">thrush combinator</a>, though I don't know if it's really
a thing.  It has nothing to do with <a href="https://en.wikipedia.org/wiki/Linear_gingival_erythema">HIV</a>.</p>
<p>The idea is that you have an initial value on which you want to perform a
sequence of transformations.  For example, in a UNIX shell, you might write</p>
<pre><code class="lang-console hljs"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> foobar | tr i x | sed <span class="hljs-string">'s/./\0\n/g'</span> | sort | uniq -c | sort -rn | head -1</span>
      2 o
</code></pre>
<p>In programming languages with function invocation syntax, you might write</p>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">const</span> result = finally_this(and_then_this(then_this(do_this(initial_data))))
</code></pre>
<p>The order in which those functions are applied reads right-to-left:</p>
<ol>
<li>You start with <code>initial_data</code>,</li>
<li>then you apply <code>do_this</code> to <code>initial_data</code>,</li>
<li>then you apply <code>then_this</code> to the result of (2),</li>
<li>then you apply <code>and_then_this</code> to the result of (3),</li>
<li>then you apply <code>finally_this</code> to the result of (4),</li>
<li>and then (5) is the answer.</li>
</ol>
<p><code>thrush</code> allows you to rewrite that expression in the following way:</p>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">const</span> result =
    thrush(initial_data, do_this, then_this, and_then_this, finally_this);
</code></pre>
<p>That looks more like the shell pipeline.  It also looks like a sequence of
statements in an imperative programming language, where there is an implicit
<a href="https://en.wikipedia.org/wiki/Sequence_point">sequence point</a> after each function invocation:</p>
<pre><code class="hljs">declare initial_data<span class="hljs-comment">;</span>
do_this()<span class="hljs-comment">;</span>
then_this()<span class="hljs-comment">;</span>
and_then_this()<span class="hljs-comment">;</span>
finally_this()<span class="hljs-comment">;</span>
</code></pre>
<p>In programming languages with objects and methods, this is sometimes expressed
as a chain of method invocations and called a <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent interface</a>:</p>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">const</span> result =
    initial_data.do_this().then_this().and_then_this().finally_this();
</code></pre>
<p>That's often formatted vertically to give an imperative feel:</p>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">const</span> result =
    initialdata
    .do_this()
    .then_this()
    .and_then_this()
    .finally_this();
</code></pre>
<p>Clojure has a macro version of the thrush combinator, spelled <a href="https://en.wikipedia.org/wiki/Fluent_interface">-&gt;</a>, and
confusingly called the "threading macro":</p>
<pre><code class="lang-clojure hljs">(<span class="hljs-keyword">def</span> <span class="hljs-title">result</span>
  (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;</span></span> initial-data do-this then-this and-then-this finally-this))
</code></pre>
<p>Getting back to the Javascript implementation from before:</p>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">const</span> thrush = <span class="hljs-function">(<span class="hljs-params">value, func, ...funcs</span>) =&gt;</span>
    func ? thrush(func(value), ...funcs) : value;
</code></pre>
<p>Isn't it cool how that works?  Maybe it's clearer with less syntax, in
<a href="https://racket-lang.org/">Racket</a>:</p>
<pre><code class="lang-scheme hljs">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">thrush</span> value . funcs)
  (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name">empty?</span> funcs)
    value
    (<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> thrush (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> ((<span class="hljs-name">first</span> funcs) value) (<span class="hljs-name">rest</span> funcs)))))
</code></pre>
<p>Yuck, that didn't help at all.  Maybe pattern matching will help.  How about
this?</p>
<pre><code class="lang-scheme hljs">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> thrush
  (<span class="hljs-name">match-lambda*</span>
    [(<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> value) value]
    [(<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> value func funcs ...) (<span class="hljs-name">thrush</span> (<span class="hljs-name">func</span> value) funcs ...)]))
</code></pre>
<p>Getting better?  Maybe it's clearer as a pattern matching <em>macro</em> instead of as
a function:</p>
<pre><code class="lang-scheme hljs">(<span class="hljs-name"><span class="hljs-builtin-name">define-syntax</span></span> thrush
  (<span class="hljs-name"><span class="hljs-builtin-name">syntax-rules</span></span> ()
    [(<span class="hljs-name">thrush</span> value) value]
    [(<span class="hljs-name">thrush</span> value func funcs ...) (<span class="hljs-name">thrush</span> (<span class="hljs-name">func</span> value) funcs ...)]))
</code></pre>
<p>They're really very similar, aren't they?</p>
<p>This makes me wonder what a horrid affair this would be in C++.  Let's try it:</p>
<pre><code class="lang-c++ hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Value&gt;
<span class="hljs-function">Value&amp;&amp; <span class="hljs-title">thrush</span><span class="hljs-params">(Value&amp;&amp; value)</span> </span>{
    <span class="hljs-keyword">return</span> std::forward&lt;Value&gt;(value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Value, <span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span> ... Funcs&gt;
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">thrush</span><span class="hljs-params">(Value&amp;&amp; value, Func&amp;&amp; func, Funcs&amp;&amp;... funcs)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">thrush</span>(<span class="hljs-built_in">func</span>(std::forward&lt;Value&gt;(value)),
                  std::forward&lt;Funcs&gt;(funcs)...);
}
</code></pre>
<p>The <code>auto</code> function with a deduced return type (i.e. without a trailing return
type) is a C++14 feature.  You know, if it weren't for the <code>std::forward</code>
noise, this would be nearly as clean as the Racket code.  Maybe we can omit the
<code>std::forward</code> calls and it will only matter sometimes.  What do I know?  Let's
see what that looks like:</p>
<pre><code class="lang-c++ hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Value&gt;
<span class="hljs-function">Value <span class="hljs-title">thrush</span><span class="hljs-params">(Value&amp;&amp; value)</span> </span>{
    <span class="hljs-keyword">return</span> value;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Value, <span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span> ... Funcs&gt;
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">thrush</span><span class="hljs-params">(Value&amp;&amp; value, Func&amp;&amp; func, Funcs&amp;&amp;... funcs)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">thrush</span>(<span class="hljs-built_in">func</span>(value), funcs...);
}
</code></pre>
<p>Hot damn!  What about using <code>class</code> instead of <code>typename</code>?</p>
<pre><code class="lang-c++ hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Value</span>&gt;</span>
<span class="hljs-function">Value <span class="hljs-title">thrush</span><span class="hljs-params">(Value&amp;&amp; value)</span> </span>{
    <span class="hljs-keyword">return</span> value;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Value</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Func</span>, <span class="hljs-keyword">class</span> ... <span class="hljs-title">Funcs</span>&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">thrush</span><span class="hljs-params">(Value&amp;&amp; value, Func&amp;&amp; func, Funcs&amp;&amp;... funcs)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">thrush</span>(<span class="hljs-built_in">func</span>(value), funcs...);
}
</code></pre>
<p>That's pretty good.  The last thing I'd do is make the first overload <code>auto</code>,
even though it doesn't save us much.  It makes the two overloads more
consistent:</p>
<pre><code class="lang-c++ hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Value</span>&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">thrush</span><span class="hljs-params">(Value&amp;&amp; value)</span> </span>{
    <span class="hljs-keyword">return</span> value;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Value</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Func</span>, <span class="hljs-keyword">class</span> ... <span class="hljs-title">Funcs</span>&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">thrush</span><span class="hljs-params">(Value&amp;&amp; value, Func&amp;&amp; func, Funcs&amp;&amp;... funcs)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">thrush</span>(<span class="hljs-built_in">func</span>(value), funcs...);
}
</code></pre>
<p>Not too shabby.  Still can't beat Javascript, though.</p>
<pre><code class="lang-javascript hljs"><span class="hljs-keyword">const</span> thrush = <span class="hljs-function">(<span class="hljs-params">value, func, ...funcs</span>) =&gt;</span>
    func ? thrush(func(value), ...funcs) : value;
</code></pre>
<p>What about in <a href="https://golang.org/">Go</a>?  Forget it.</p>


<div class="series-navigation-placeholder"></div>

<div class="navigation-bar">
    <a href="/posts.html">Posts</a>
    <a href="/series.html">Series</a>
    <a href="/mailinglist.html">Mailing List</a>
    <a href="https://github.com/dgoffredo">About</a>
    <a href="https://github.com/dgoffredo/dgoffredo.github.io">Code</a>
</div>


</body>
</html>